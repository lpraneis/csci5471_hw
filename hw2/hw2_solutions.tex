\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{url}
\usepackage{hyperref}

\usepackage{amsfonts}
\newcounter{qnum}
\newcommand{\question}[1]{\stepcounter{qnum}\bigskip\noindent{\bf \arabic{qnum}. #1.}}

\newcommand{\E}{\mathop{\textrm{E}}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cA}{\mathcal{A}}
\newcommand{\bbM}{\mathbb{M}}
\newcommand{\bbK}{\mathbb{K}}
\newcommand{\enc}{\textsf{Enc}}
\newcommand{\dec}{\textsf{Dec}}
\newcommand{\gen}{\textsf{Gen}}
\newcommand\NetIDa{prane001}          

\begin{document}
\begin{center}
  {\Large \bf CSci 5471: Modern Cryptography}
\end{center}
{\bf Homework 2} \hfill {\bf due: March 7, 2019}
\newline
{\bf \NetIDa} \hfill  
\medskip
\hrule
\medskip

\newcommand{\fsec}[1]{\textsf{Fsec}_{#1}}
\newcommand{\adv}[1]{\textsf{Adv}({#1})}
\newcommand{\st}{\textsf{st}} \newcommand{\evolve}{\textsf{evolve}}
\question{Stream Ciphers, Pseudorandomness, and Distinguishers} [15 points] 
\begin{itemize}
\item[(a)] 
  $G$ is a pseudorandom generator iff: $| \Pr[D(s) =1 ] - \Pr[D(r) =1]| \leq negl(n)$
  Via p.62 of \textit{Katz and Lindell}, we need to prove the three properties of a
  PRG:
  \begin{enumerate}
    \item{} $G(s, 1^n)$ outputs a stream of length $n$
    \item{} $\forall n l(n) > n$
    \item{} $\forall PPT D, \exists negl s.t. | \Pr[D(G(s))=1] - \Pr[D(r)=1]| \leq negl(n)$
  \end{enumerate}
  The first two come from the definition of $\textsf{init}, \textsf{evolve}$. The proof of the PRG
  property then comes from the 3rd property. We can prove this using the given statement that:
  $\Pr[\fsec{\cA,G}(n)=1] \leq \frac{1}{2} + \varepsilon(n)$.
  \begin{align}
 & \Pr[\fsec{\cA,G}(n)=1] \leq \frac{1}{2} + \varepsilon(n) \rightarrow \\
   &|\Pr[\fsec{\cA,G}(n)=1]  - \frac{1}{2}| \leq \varepsilon(n).\\
    \text{Since $\Pr[D(r) =1] = \frac{1}{2}$}, &\nonumber\\
   &|\Pr[\fsec{\cA,G}(n)=1]  - \Pr[D(r)=1] |\leq \varepsilon(n).\\
   &|\Pr[D(G(s))=1] - \Pr[D(r)=1]| \leq \varepsilon(n).
\end{align}
This conclusion comes from the usage of the Forward Security definitions in modeling a 
PRG, where $D$ is a distinguished that uses \evolve(.) and $\textsf{init}(.)$ to follow
through the forward security game.
\item[(b)]
  Let $G(s)$ be the oracle for the Enigma Machine and $\mathcal{F}$ be a truly random function.
  We want to find $\adv{D}$. The definition says that 
  $\adv{D} = | \Pr[D(\mathcal{F})=1] - \Pr[D(G(s)=1]|$ and so we can find the probabilities below.
  Let a Distinguisher, D, return 1 if it was playing
  against the $G(s)$ and 0 if it was playing against a truly random function.
  $\Pr[D(\mathcal{G})=1] = 1$, as if there is not a zero word, the Distinguisher can tell
  with probability 1. The next probability depends on whether or not a zero appears
  from the $\mathcal{F}$, which is shown below.

  $\Pr[D(F)=1] = 1 - \left( \frac{1}{2^w}\right)^{\frac{m* 2^w}{w}}$
  and so, $\adv{D} =\left( \frac{1}{2^w}\right)^{\frac{m* 2^w}{w}}$
\item[(c)] 
  Let our distinguisher, $D$ work as follows:
  \begin{enumerate}
    \item Get a stream of words
    \item Find every pair of words
    \item Output 1 if there is a pair of zero bytes and 0 if there is not
  \end{enumerate}
  Using $\mathcal{F}$ as the random function and $R$ as the $RC4$ implementation.
  We can calculate the $\adv{D}$ with the two probabilities below.
  \begin{align}
    \text{Given: } m*2^{16} \text{ total words}& \nonumber \\
    \text{Given: } m*2^{16} -1 \text{ total pairs}& \nonumber \\
    \Pr[D(\mathcal{F}) = 1]& = \frac{1}{2^{64}} ^ {m*2^{16} -1 } \nonumber \\
    \Pr[D(R) = 1]& = \left(\frac{1}{2^{16}} + \frac{1}{2^{24}} \right) ^ {m*2^{16} -1 } \nonumber \\
    \adv{D} =&| \frac{1}{2^{64}} ^ {m*2^{16} -1 } -  \left(\frac{1}{2^{16}} + \frac{1}{2^{24}} \right) ^ {m*2^{16} -1 } |  \nonumber \\
  \end{align}
\end{itemize}

\question{Balls and Bins and Random Mappings} [20 points]
\begin{itemize}
\item[(a)] 
  Let $X_1 , X_2, \cdots , X_n $ be the indicator variable for whether or not a bin is empty.
  Let $Y = X_1 + X_2 + \cdots + X_n$. We want to find $\E[Y]$. 
  \[
    \Pr[\bar{X_i}] = (1 - \frac{1}{n})^m, \\
    \Pr[X_i] = 1 - (1 - \frac{1}{n})^m, 
  \]
  By the linearity of expectation, $\E[Y] = n - n(\frac{n-1}{n})^m$ \\
  And so,   $\E[\geq 1] = n - n\left(\frac{n-1}{n}\right)^m$
\item[(b)]
  Simply substituting in, 
  \[
    \E[\geq 1] = n - n\left(\frac{n-1}{n}\right)^{\alpha*n} 
  \]
\item[(c)] 
  TODO
\item[(d)] 
  Since y is uniformly distributed, we can assume probability of 
  $y \equiv t \pmod p = \frac{1}{p}$, 
  where $t$ ranges over the values of $\{0 , \cdots, p-1\}$. Since $f$ has a degree bound
  by $d$, it has at most $d$ roots. We can bound this probability via the following realizaton:
  \[
    \Pr[f(x) \equiv y] \leq \Pr[f(x) \equiv 0]
  \]
  This comes via choosing a fixed y. Since $f(x) \equiv 0$ has d roots, we can conclude
  \[
    \Pr[f(x) \equiv y] \leq \Pr[f(x) \equiv 0] \leq \frac{d}{p}
  \]
\item[(e)] TODO - EC 
\end{itemize}

\question{Block Ciphers, PRPs and PRFs} [20 points]
\begin{itemize}
\item[(a)] 
  $E' : \{0,1\}^{k+\ell} \times\{0,1\}^\ell \rightarrow \{0,1\}^\ell$
  The key length for this block cipher is : $k +\ell$ and the block
  length is : $\ell$. We define $E'_{K||P}(x) = E_K(P\oplus x)$. We can break this 
  scheme the exact same way as if it didn't have the pad by exploiting the fact that some
  of the $P$ will be the zero word, $0^\ell$. We can simply use the $2^k$ trial decryptions
  by guessing $E_k(P \oplus x)$ where $P = 0^\ell$ so $P \oplus x = x$. Therefore, 
  $E'_{K||P}(x) = E_k(x)$, which can be broken in $2^k$ trials.
\item[(b)] 
  \begin{itemize}
    \item[(i)]
      This construction is invertible, because, given $\rho$, we know 
      \begin{align}
  & (L,R) \mapsto (L\oplus\rho(L\oplus R), R \oplus \rho(L\oplus R)) \nonumber \\
  &  \rho(L\oplus\rho(L\oplus R) \oplus R \oplus \rho(L\oplus R)) \nonumber \\
        = & \rho(L\oplus R) \nonumber \\
        \text{And thus, }&\nonumber \\
                         & L\oplus \rho(L\oplus R) \oplus \rho(L\oplus R) = L \nonumber \\
                         & R\oplus \rho(L\oplus R) \oplus \rho(L\oplus R) = R \nonumber 
      \end{align}
    \item[(ii)] This construction is not secure for $n$ rounds. A demonstration of the 
      rounds is shown below:
      \begin{align}
        \tag{Round 1}  L &, R  \\
        \tag{Round 2} L \oplus \rho(L\oplus R)  &, R \oplus \rho(L\oplus R)  \\
        \tag{Round 3} L \oplus \rho(L\oplus R)  &, R \oplus \rho(L\oplus R)  \\
        \tag{Round n} L \oplus \rho(L\oplus R)  &, R \oplus \rho(L\oplus R)  
      \end{align}
      This works, as each round above 2, the $\rho(L\oplus R)$ will cancel out with the xor
      and leave only the $L\oplus R$. This is not a secure PRP as an oracle could check against
      $L\oplus R$ and see whether the output was generated by this algorithm or a true PRP.
  \end{itemize}
\item[(d)] TODO - EC
\end{itemize}

\question{Block Cipher Modes} [20 points]  One of the common mistakes
that software developers make in their use of crypto is trying to
design their own block cipher modes of operation (Excluding the
developers that know not to use ECB mode).  Let's analyze a few
possibilities. 
\begin{itemize}
\item[(a)] TODO 
\item[(b)] TODO
\item[(c)] TODO
\item[(d)] TODO  - EC
\end{itemize}

\question{Cryptanalysis: Un-chain my block} [25 points] Perhaps
because of Schneier's endorsement, or because it just seems more
complicated, CBC mode is a popular choice among fielded
cryptosystems.  Unfortunately, CBC can also be fairly easy to get
wrong: real implementations have turned out to be vulnerable to
several unfortunate attacks.
\begin{itemize}
\item[(a)] If we know the IV in advance, we can construct a distinguisher like so:
  \begin{enumerate}
    \item Ask for an IV, call this $IV^0$.
    \item Query the encryption oracle with $m^t = IV^0 || m^t_1 || \cdots || m^t_n$
    \item This will give us $\enc_{k_1}(0)$
    \item Now that this is found, query for the next IV, call this $IV^*$
    \item Without breaking the no-repeat property of a distinguisher, we can construct 
      2 messages as following, where $m^i_j \neq m^t_j$ for all $0\leq j \leq n$:
      \begin{itemize}
        \item $m_0 = m^0_0 || m0^1_1 || \cdots || m^0_n$
        \item $m_1 = IV^* || m1^1_1 || \cdots || m^1_n$
      \end{itemize}
    \item The distinguisher can then find the message with probability 1 as the first
      block will match the block found from the initial query with $m^t$, as it will be
      equal to $\enc_{k_1}(0)$.
  \end{enumerate}
\item[(b)] 
  \textbf{Secret String}: 
      'Zeppelin'

  \textbf{Algorithm}:
      At a high level, the algorithm used exploited the fact that each
      block encrytion key was the same throughout the rounds in addition to 
      the fact that we could know the IV ahead of time. The algorithm worked as follows:
  \begin{itemize}
    \item Find the IV for the next encrytion
    \item Set the first block of the plaintext as the IV
    \item Set the second block of the plaintext as all zeros, except the byte of
      the secret string currently being guessed
    \item Find the encryption of 0..0B where B is the byte of the secret string currently
      being guessed
    \item Then, try all 256 possibilities for this byte, encrypting each possibility to find 
      a match.
    \item Once a match is found, add this byte to the answer byte string and move on to 
      guessing the next byte
    \item After all bytes are found, return the bytestring
  \end{itemize}
\item[(c)] TODO - EC 

\end{itemize}

\end{document}
